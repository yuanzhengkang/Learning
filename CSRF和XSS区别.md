CSRF：跨站请求伪造
	  攻击原理：用户登陆受信任网站A，并在本地生成cookie，如果没有登陆，当访问危险网站B的时候，危险网站B会请求A的api接口，会提示你登陆
			   在不登出A的情况下访问危险网站B
	  如何防御：Token验证
				  服务器发送给客户端一个Token
				  客户端提交表单时带着这个Token
				  如果Token不合法，那么服务器拒绝这个请求
				隐藏令牌
				  把Token隐藏在http的head头中，跟Token验证的方法有点像，本质上没有区别，只是使用方式有区别
				Referer
				  Referer指的是页面请求来源，意思是，只接受本站的请求，服务器才做响应，如果不是，就拦截
XSS：跨域脚本攻击
	   攻击原理：XSS攻击的核心原理是：不需要你做任何的登陆认证，它会通过合法的操作（比如URL中输入，在评论框中输入，向你的页面注入代码(有可能是js代码，html代码块等)
	   导致的结果就是：cookie被盗用  破坏页面的正常结构，植入广告等恶意内容，D-doss攻击
	   攻击方式：反射性：发出请求时，XSS代码会出现在URL中，作为输入提交到服务器端，服务器端解析后响应，XSS代码随响应内容一起传回给浏览器，最后浏览器解析执行XSS代码
			    这个过程像一次反射，所以叫反射型XSS
				存储型：存储型XSS和反射型XSS的差别在于，提交的代码会存储在服务器端(数据库，内存，文件系统等)，下次请求时目标页面时不用再提交XSS代码。
				
				XSS的防范措施（encode + 过滤）

XSS的防范措施主要有三个：

1、编码：

对用户输入的数据进行

HTML Entity

编码。

如上图所示，把字符转换成 转义字符。

Encode的作用是将

$var

等一些字符进行转化，使得浏览器在最终输出结果上是一样的。

比如说这段代码：

<script>alert(1)</script>

若不进行任何处理，则浏览器会执行alert的js操作，实现XSS注入。

进行编码处理之后，L在浏览器中的显示结果就是

<script>alert(1)</script>

，实现了将$var作为纯文本进行输出，且不引起JavaScript的执行。

参考链接：4类防御XSS的有效方法

2、过滤：

移除用户输入的和事件相关的属性。如onerror可以自动触发攻击，还有onclick等。（总而言是，过滤掉一些不安全的内容）
移除用户输入的Style节点、Script节点、Iframe节点。（尤其是Script节点，它可是支持跨域的呀，一定要移除）。
3、校正

避免直接对HTML Entity进行解码。
使用DOM Parse转换，校正不配对的DOM标签。
备注：我们应该去了解一下

DOM Parse

这个概念，它的作用是把文本解析成DOM结构。

比较常用的做法是，通过第一步的编码转成文本，然后第三步转成DOM对象，然后经过第二步的过滤。

还有一种简洁的答案：

首先是encode，如果是富文本，就白名单。

CSRF 和 XSS 的区别

面试官还可能喜欢问二者的区别。

区别一：

CSRF：需要用户先登录网站A，获取 cookie。
XSS：不需要登录。
区别二：（原理的区别）

CSRF：是利用网站A本身的漏洞，去请求网站A的api。
XSS：是向网站 A 注入 JS代码，然后执行 JS 里的代码，篡改网站A的内容。